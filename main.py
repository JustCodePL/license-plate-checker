import os
import time
import cv2
from paddleocr import PaddleOCR
import numpy as np
import sys
import threading
import platform
import pathlib
import requests
from dotenv import load_dotenv

load_dotenv()

print(f"AAA {os.environ.get('DOCKER_CONTAINER')}")

# Wykrycie systemu operacyjnego
SYSTEM_OS = platform.system().lower()
IS_WINDOWS = SYSTEM_OS == 'windows'
IS_LINUX = SYSTEM_OS == 'linux'
IS_MACOS = SYSTEM_OS == 'darwin'

print(f"üñ•Ô∏è  Wykryto system: {platform.system()} {platform.release()}")

# Pobierz konfiguracjƒô z ENV - uniwersalnƒÖ dla wszystkich system√≥w
CAMERA_URL = os.getenv('CAMERA_URL', '')
CAMERA_TYPE = 'usb' if CAMERA_URL.isnumeric() else 'ip'
DEBUG_MODE = os.getenv('DEBUG_MODE', 'false').lower() == 'true'
WEBHOOK_URL = os.getenv('WEBHOOK_URL', '')

# Inicjalizacja OCR z mniejszym modelem i timeout
ocr = None

def get_camera():
    """Inicjalizuj kamerƒô z optymalizacjami dla r√≥≈ºnych system√≥w"""

    if CAMERA_TYPE == 'usb':
        try:
            cam_index = int(CAMERA_URL)
        except ValueError:
            cam_index = 0

        # R√≥≈ºne backendy dla r√≥≈ºnych system√≥w
        if IS_WINDOWS:
            # Windows: DirectShow jest czƒôsto najlepszy
            cap = cv2.VideoCapture(cam_index, cv2.CAP_DSHOW)
            if not cap.isOpened():
                # Fallback na domy≈õlny backend
                cap = cv2.VideoCapture(cam_index)
        elif IS_LINUX:
            # Linux: V4L2 jest native
            cap = cv2.VideoCapture(cam_index, cv2.CAP_V4L2)
            if not cap.isOpened():
                # Fallback na domy≈õlny backend
                cap = cv2.VideoCapture(cam_index)
        elif IS_MACOS:
            # macOS: AVFoundation
            cap = cv2.VideoCapture(cam_index, cv2.CAP_AVFOUNDATION)
            if not cap.isOpened():
                # Fallback na domy≈õlny backend
                cap = cv2.VideoCapture(cam_index)
        else:
            # Nieznany system - u≈ºyj domy≈õlnego
            cap = cv2.VideoCapture(cam_index)

    elif CAMERA_TYPE == 'ip':
        cap = cv2.VideoCapture(CAMERA_URL)
    else:
        raise ValueError('Nieznany typ kamery: {}'.format(CAMERA_TYPE))

    if not cap.isOpened():
        error_msg = f'Nie mo≈ºna otworzyƒá kamery!'
        if CAMERA_TYPE == 'usb':
            error_msg += f'\nüí° Sprawd≈∫:'
            if IS_WINDOWS:
                error_msg += f'\n  - Czy kamera jest pod≈ÇƒÖczona i rozpoznana w Device Manager'
                error_msg += f'\n  - Czy ≈ºadna inna aplikacja nie u≈ºywa kamery'
            elif IS_LINUX:
                error_msg += f'\n  - ls /dev/video* (sprawd≈∫ dostƒôpne urzƒÖdzenia)'
                error_msg += f'\n  - Uprawnienia u≈ºytkownika do grupy video'
            elif IS_MACOS:
                error_msg += f'\n  - Uprawnienia do kamery w System Preferences > Privacy'
        raise RuntimeError(error_msg)

    # OPTYMALIZACJE DLA AKTUALNO≈öCI KLATEK
    # Ustaw ma≈Çy bufor aby zawsze pobieraƒá najnowsze klatki
    cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)

    print(f"üìπ Kamera otwarta ({CAMERA_TYPE}): {CAMERA_URL}")
    return cap

def optimize_camera_for_system(cap):
    """Zastosuj optymalizacje kamery specyficzne dla systemu operacyjnego"""
    optimizations_applied = 0

    try:
        # Optymalizacje wsp√≥lne dla wszystkich system√≥w
        original_fps = cap.get(cv2.CAP_PROP_FPS)

        # OPTYMALIZACJA 1: Ustaw rozdzielczo≈õƒá dla wydajno≈õci
        if cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280) and cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720):
            width = cap.get(cv2.CAP_PROP_FRAME_WIDTH)
            height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)
            print(f"  ‚úì Rozdzielczo≈õƒá: {width:.0f}x{height:.0f}")
            optimizations_applied += 1

        # OPTYMALIZACJA 2: FPS
        if cap.set(cv2.CAP_PROP_FPS, 30):
            new_fps = cap.get(cv2.CAP_PROP_FPS)
            print(f"  ‚úì FPS: {original_fps:.1f} -> {new_fps:.1f}")
            optimizations_applied += 1

        # Optymalizacje specyficzne dla systemu
        if IS_WINDOWS:
            # Windows-specific optimizations
            if hasattr(cv2, 'CAP_PROP_BUFFER_SIZE'):
                if cap.set(cv2.CAP_PROP_BUFFER_SIZE, 1):
                    print("  ‚úì Ma≈Çy bufor kamery (Windows)")
                    optimizations_applied += 1

        elif IS_LINUX:
            # Linux-specific optimizations
            if hasattr(cv2, 'CAP_PROP_BUFFER_SIZE'):
                if cap.set(cv2.CAP_PROP_BUFFER_SIZE, 2):  # Linux mo≈ºe potrzebowaƒá wiƒôkszego bufora
                    print("  ‚úì Zoptymalizowany bufor kamery (Linux)")
                    optimizations_applied += 1

            # Na Linux czƒôsto mo≈ºna ustawiƒá fourcc dla lepszej wydajno≈õci
            if hasattr(cap, 'set') and hasattr(cv2, 'VideoWriter_fourcc'):
                cap.set(cv2.CAP_PROP_FOURCC, cv2.VideoWriter_fourcc('M', 'J', 'P', 'G'))
                print("  ‚úì Ustawiono MJPEG codec (Linux)")
                optimizations_applied += 1

        elif IS_MACOS:
            # macOS-specific optimizations
            # Na macOS czƒôsto nie mo≈ºna ustawiƒá BUFFER_SIZE, wiƒôc pomijamy
            print("  ‚úì Konfiguracja dla macOS")
            optimizations_applied += 1

        # OPTYMALIZACJA 3: Wy≈ÇƒÖcz auto-exposure je≈õli dostƒôpne
        if hasattr(cv2, 'CAP_PROP_AUTO_EXPOSURE'):
            # R√≥≈ºne systemy mogƒÖ mieƒá r√≥≈ºne warto≈õci dla wy≈ÇƒÖczenia auto-exposure
            if IS_LINUX:
                cap.set(cv2.CAP_PROP_AUTO_EXPOSURE, 0.25)  # Linux
            else:
                cap.set(cv2.CAP_PROP_AUTO_EXPOSURE, 0)  # Windows/macOS
            print("  ‚úì Wy≈ÇƒÖczono auto-exposure")
            optimizations_applied += 1

        print(f"üöÄ Zastosowano {optimizations_applied} optymalizacji dla {platform.system()}")

    except Exception as e:
        print(f"‚ö†Ô∏è Niekt√≥re optymalizacje kamery niedostƒôpne: {e}")
        print("  üìù System bƒôdzie dzia≈Ça≈Ç z domy≈õlnymi ustawieniami")

def init_ocr():
    global ocr
    if ocr is None:
        try:
            # Sprawd≈∫ instalacjƒô przed inicjalizacjƒÖ
            print("üîç Sprawdzanie instalacji PaddlePaddle...")
            try:
                import paddle
                import paddleocr
                print(f"‚úÖ PaddlePaddle: {paddle.__version__}")
                print(f"‚úÖ PaddleOCR: {paddleocr.__version__}")

                # Test podstawowej funkcjonalno≈õci
                print("üîç Test GPU/CUDA...")
                print(f"   paddle.device.get_device(): {paddle.device.get_device()}")
                try:
                    cuda_count = paddle.device.cuda.device_count()
                    print(f"   paddle.device.cuda.device_count(): {cuda_count}")
                except Exception as e:
                    print(f"   ‚ö†Ô∏è  paddle.device.cuda.device_count() error: {e}")

            except ImportError as e:
                print(f"‚ùå B≈ÇƒÖd importu: {e}")
                print("üí° Spr√≥buj: pip install paddlepaddle-gpu paddleocr")
                return
            except Exception as e:
                print(f"‚ùå B≈ÇƒÖd testowania: {e}")

            print("üîß Inicjalizacja PaddleOCR...")
            print("UWAGA: Pierwsze uruchomienie mo≈ºe trwaƒá kilka minut - pobieranie modeli...")

            # Sprawd≈∫ dostƒôpno≈õƒá GPU na r√≥≈ºnych systemach
            use_gpu = False
            gpu_info = "CPU"

            try:
                import paddle
                print(f"‚úÖ PaddlePaddle zaimportowany: {paddle.__version__}")

                # Nowy spos√≥b detekcji GPU
                device_info = paddle.device.get_device()
                cuda_count = 0
                try:
                    cuda_count = paddle.device.cuda.device_count()
                except Exception as e:
                    print(f"‚ö†Ô∏è  paddle.device.cuda.device_count() error: {e}")

                gpu_available = device_info.startswith('gpu') or cuda_count > 0

                if gpu_available:
                    use_gpu = True
                    if IS_LINUX:
                        gpu_info = "GPU/CUDA (Linux)"
                    elif IS_WINDOWS:
                        gpu_info = "GPU/CUDA (Windows)"
                    elif IS_MACOS:
                        gpu_info = "GPU/Metal (macOS)"
                    else:
                        gpu_info = "GPU/CUDA"
                    print(f"üöÄ Wykryto GPU! {gpu_info}")
                else:
                    use_gpu = False
                    if IS_WINDOWS:
                        gpu_info = "CPU (Windows - brak GPU/CUDA)"
                    elif IS_LINUX:
                        gpu_info = "CPU (Linux - brak GPU/CUDA)"
                    elif IS_MACOS:
                        gpu_info = "CPU (macOS - brak GPU/Metal)"
                    else:
                        gpu_info = "CPU (brak GPU)"
                    print(f"üîß U≈ºywam: {gpu_info}")
            except ImportError as import_e:
                print(f"‚ùå B≈ÇƒÖd importu PaddlePaddle: {import_e}")
                print("üîß U≈ºywam: CPU (b≈ÇƒÖd importu Paddle)")
            except Exception as e:
                print(f"‚ùå Nieoczekiwany b≈ÇƒÖd PaddlePaddle: {e}")
                print("üîß U≈ºywam: CPU (nie mo≈ºna sprawdziƒá Paddle)")

            # PaddleOCR inicjalizacja uniwersalna dla wszystkich system√≥w
            ocr = PaddleOCR(
                use_angle_cls=True,
                lang='en',
                use_gpu=use_gpu,
                show_log=False,  # wy≈ÇƒÖcz verbose aby zmniejszyƒá warnings
                drop_score=0.3,  # obni≈º pr√≥g pewno≈õci dla lepszej detekcji
                # U≈ºyj systemowego katalogu cache
                use_pdserving=False,  # Wy≈ÇƒÖcz serwisy dla lepszej kompatybilno≈õci
                enable_mkldnn=not IS_MACOS  # MKLDNN mo≈ºe nie dzia≈Çaƒá na macOS
            )

            print(f"‚úÖ PaddleOCR gotowy na {platform.system()}!")

        except ImportError as e:
            print(f"‚ùå B≈ÇƒÖd importu PaddleOCR: {e}")
            print("üì¶ Zainstaluj wymagane pakiety:")
            if IS_WINDOWS:
                print("   pip install paddleocr paddlepaddle")
                print("   # Dla GPU na Windows: pip install paddlepaddle-gpu")
                print("   # CUDA 11.8: pip install paddlepaddle-gpu==3.1.0 -i https://www.paddlepaddle.org.cn/packages/stable/cu118/")
                print("   # CUDA 12.6: pip install paddlepaddle-gpu==3.1.0 -i https://www.paddlepaddle.org.cn/packages/stable/cu126/")
            elif IS_LINUX:
                print("   pip install paddleocr paddlepaddle")
                print("   # Dla GPU na Windows/Linux: pip install paddlepaddle-gpu")
                print("   # CUDA 11.8: pip install paddlepaddle-gpu==3.1.0 -i https://www.paddlepaddle.org.cn/packages/stable/cu118/")
                print("   # CUDA 12.6: pip install paddlepaddle-gpu==3.1.0 -i https://www.paddlepaddle.org.cn/packages/stable/cu126/")
            elif IS_MACOS:
                print("   pip install paddleocr paddlepaddle")
            ocr = None
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd inicjalizacji OCR: {e}")
            print("üåê Sprawd≈∫ po≈ÇƒÖczenie internetowe - potrzebne do pobrania modeli")
            if DEBUG_MODE:
                import traceback
                traceback.print_exc()
            ocr = None

def preprocess_image_for_ocr(frame):
    """Ulepsz obraz przed OCR - specjalnie dla tablic rejestracyjnych"""
    try:
        # Konwersja do skali szaro≈õci je≈õli kolorowy
        if len(frame.shape) == 3:
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        else:
            gray = frame

        # Zwiƒôksz kontrast dla lepszej czytelno≈õci
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
        enhanced = clahe.apply(gray)

        # Filtruj szum
        denoised = cv2.medianBlur(enhanced, 3)

        # Konwertuj z powrotem do BGR dla PaddleOCR
        bgr = cv2.cvtColor(denoised, cv2.COLOR_GRAY2BGR)

        return bgr
    except Exception as e:
        if DEBUG_MODE:
            print(f"B≈ÇƒÖd przetwarzania obrazu: {e}")
        return frame

def detect_and_read_plate(frame):
    global ocr
    if ocr is None:
        return None

    try:
        # Ulepsz obraz przed OCR
        processed_frame = preprocess_image_for_ocr(frame)

        # Uruchom OCR z klasyfikacjƒÖ kƒÖta dla lepszej detekcji
        result = ocr.ocr(processed_frame, cls=True)

        if result and len(result) > 0 and result[0] is not None:
            if DEBUG_MODE:
                print(f"OCR wykry≈Ç {len(result[0])} tekst√≥w:")

            best_candidates = []

            # Przeszukaj wszystkie wykryte teksty
            for detection in result[0]:
                if len(detection) >= 2:
                    text = detection[1][0].strip()  # detection[1][0] to tekst w PaddleOCR
                    confidence = detection[1][1]     # detection[1][1] to pewno≈õƒá

                    if DEBUG_MODE:
                        print(f"  '{text}' (pewno≈õƒá: {confidence:.2f})")

                    # Wyczy≈õƒá tekst - usu≈Ñ spacje i znaki specjalne
                    import re
                    clean_text = re.sub(r'[^A-Z0-9]', '', text.upper())

                    # Filtruj potencjalne tablice rejestracyjne z ni≈ºszym progiem
                    if clean_text and len(clean_text) >= 4 and confidence > 0.3:
                        if is_license_plate(clean_text):
                            best_candidates.append((clean_text, confidence))
                            if DEBUG_MODE:
                                print(f"  -> Kandydat: '{clean_text}' (pewno≈õƒá: {confidence:.2f})")

            # Zwr√≥ƒá najlepszy kandydat
            if best_candidates:
                best_candidates.sort(key=lambda x: x[1], reverse=True)
                return best_candidates[0][0]

        elif DEBUG_MODE:
            print("OCR nie wykry≈Ç ≈ºadnego tekstu")

    except Exception as e:
        print(f"B≈ÇƒÖd OCR: {e}")
        if DEBUG_MODE:
            import traceback
            traceback.print_exc()
        return None
    return None

def is_license_plate(text):
    """Sprawd≈∫ czy tekst mo≈ºe byƒá tablicƒÖ rejestracyjnƒÖ"""
    import re

    # Usu≈Ñ spacje i znaki specjalne
    clean_text = re.sub(r'[^A-Z0-9]', '', text.upper())

    # Sprawd≈∫ d≈Çugo≈õƒá (tablice zwykle 4-8 znak√≥w)
    if len(clean_text) < 4 or len(clean_text) > 8:
        return False

    # Sprawd≈∫ czy zawiera cyfry i litery (typowe dla tablic)
    has_letters = bool(re.search(r'[A-Z]', clean_text))
    has_numbers = bool(re.search(r'[0-9]', clean_text))

    return has_letters and has_numbers

def test_system():
    """Test systemu - uniwersalny dla Windows/Linux/macOS"""
    print(f"=== TEST SYSTEMU {platform.system().upper()} ===")

    # Test OpenCV
    try:
        import cv2
        opencv_version = cv2.__version__
        print(f"‚úì OpenCV {opencv_version} - OK")

        # Sprawd≈∫ dostƒôpne w≈Ça≈õciwo≈õci kamery (r√≥≈ºne na r√≥≈ºnych systemach)
        available_props = []
        test_props = [
            ('BUFFER_SIZE', 'CAP_PROP_BUFFER_SIZE'),
            ('FPS', 'CAP_PROP_FPS'),
            ('FRAME_WIDTH', 'CAP_PROP_FRAME_WIDTH'),
            ('FRAME_HEIGHT', 'CAP_PROP_FRAME_HEIGHT'),
            ('AUTO_EXPOSURE', 'CAP_PROP_AUTO_EXPOSURE')
        ]

        for prop_name, prop_attr in test_props:
            if hasattr(cv2, prop_attr):
                available_props.append(prop_name)

        if available_props:
            print(f"  ‚úì Dostƒôpne w≈Ça≈õciwo≈õci kamery: {', '.join(available_props)}")
        else:
            print(f"  ‚ö†Ô∏è Ograniczone w≈Ça≈õciwo≈õci kamery (OpenCV {opencv_version})")

    except ImportError:
        print("‚úó OpenCV - BRAK")
        print("üì¶ Instalacja:")
        if IS_WINDOWS:
            print("   pip install opencv-python")
        elif IS_LINUX:
            print("   pip install opencv-python")
            print("   # Lub: sudo apt install python3-opencv")
        elif IS_MACOS:
            print("   pip install opencv-python")
            print("   # Lub: brew install opencv")
        return False

    # Test PaddleOCR
    try:
        from paddleocr import PaddleOCR
        print("‚úì PaddleOCR import - OK")
    except ImportError:
        print("‚úó PaddleOCR - BRAK")
        print("Zainstaluj: pip install paddleocr paddlepaddle")
        return False

    # Test numpy
    try:
        import numpy as np
        print("‚úì NumPy - OK")
    except ImportError:
        print("‚úó NumPy - BRAK")
        return False

    print("‚úì Wszystkie wymagane biblioteki dostƒôpne")
    return True

def send_to_webhook(plate):
    """Wysy≈Ça dane do webhooku"""

    if WEBHOOK_URL == "":
        print(f"Pomijam wysy≈Çanie do webhooku - WEBHOOK_URL jest pusty")
        return

    try:
        response = requests.post(WEBHOOK_URL, json={"plate": plate})
        if response.status_code == 200:
            print(f"‚úÖ Wys≈Çano do webhooku: {plate}")
        else:
            print(f"‚ùå B≈ÇƒÖd przy wysy≈Çaniu do webhooku: {response.status_code}")
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd przy wysy≈Çaniu do webhooku: {e}")

def main():
    print("=== SYSTEM ROZPOZNAWANIA TABLIC REJESTRACYJNYCH ===")
    print(f"üåç Uniwersalny system dla {platform.system()}")
    print()

    # Test systemu - sprawd≈∫ kompatybilno≈õƒá
    if not test_system():
        print(f"\n‚ùå B≈ÇƒÖd: Nie wszystkie wymagane komponenty sƒÖ dostƒôpne na {platform.system()}!")
        print("üì¶ Zainstaluj brakujƒÖce pakiety i spr√≥buj ponownie.")
        return

    print()

    # Inicjalizacja OCR
    print("üîß Inicjalizacja PaddleOCR...")
    init_ocr()

    if ocr is None:
        print("‚ùå B≈ÇƒÖd: Nie mo≈ºna zainicjalizowaƒá PaddleOCR!")
        print("üåê Sprawd≈∫ po≈ÇƒÖczenie internetowe - potrzebne do pobrania modeli")
        return

    print("‚úÖ PaddleOCR zainicjalizowany")
    print("üìπ ≈ÅƒÖczƒô z kamerƒÖ...")

    # Po≈ÇƒÖczenie z kamerƒÖ
    try:
        cap = get_camera()

        # Optymalizacje kamery specyficzne dla systemu
        print("üîß Konfigurujƒô optymalizacje kamery...")
        optimize_camera_for_system(cap)

    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd po≈ÇƒÖczenia z kamerƒÖ: {e}")
        return

    print()
    print(f"üöó SYSTEM AKTYWNY - {platform.system()} - rozpoznawanie tablic...")
    print("‚å®Ô∏è  Naci≈õnij Ctrl+C aby zatrzymaƒá")
    print("-" * 50)

    try:
        analysis_running = False

        while True:
            if (not analysis_running):
                # OPR√ì≈ªNIJ BUFOR - pobieraj klatki przez 0.5 sekundy
                start_flush = time.time()
                flushed = 0
                while time.time() - start_flush < 0.5:
                    cap.grab()
                    flushed += 1
                if DEBUG_MODE:
                    print(f"[DEBUG] Opr√≥≈ºniono bufor, odrzucono {flushed} klatek")

                # POCZEKAJ NA NOWƒÑ KLATKƒò
                time.sleep(0.05)  # 50 ms
                ret, frame = cap.read()
                if not ret:
                    print("‚ö†Ô∏è  Brak obrazu z kamery! Pr√≥bujƒô ponownie za 2 sekundy...")
                    time.sleep(2)
                    continue

                if DEBUG_MODE:
                    print(f"[{time.strftime('%H:%M:%S')}] Rozpoczynam analizƒô klatki...")

                analysis_running = True

                analysis_started_at = time.time()
                # Rozpoznawanie tablicy
                plate = detect_and_read_plate(frame)

                analysis_ended_at = time.time()
                analysis_duration = analysis_ended_at - analysis_started_at

                analysis_running = False  # Zako≈Ñcz flagƒô analizy

                if plate:
                    timestamp = time.strftime("%H:%M:%S", time.localtime())
                    print(f"üéØ [{timestamp}] WYKRYTO TABLICƒò: {plate} w ciƒÖgu {analysis_duration:.2f} sekund")
                    send_to_webhook(plate)

    except KeyboardInterrupt:
        print("\n" + "="*50)
        print("üõë Zatrzymano przez u≈ºytkownika")
    except Exception as e:
        print(f"\n‚ùå B≈ÇƒÖd podczas przetwarzania: {e}")
        if DEBUG_MODE:
            import traceback
            traceback.print_exc()
    finally:
        try:
            cap.release()
            print("üì∑ Kamera zwolniona")
        except:
            pass
        print(f"üëã Do widzenia z {platform.system()}!")

if __name__ == "__main__":
    main()